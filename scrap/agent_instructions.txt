Be Precise
- one task at a time
- break down complexity into small tasks
- make prompts specified and detailed

Be Organized
- tidy projects
    - add features step by step
    - test features after each addition
- start fresh chat each new features
- be willing to roll back to prior commits

Be patient
- build an understanding
- review code before accepting
- debugging is time consuming: with or without an agent

Main skills: thinking, framework, checkpoints, debugging, context
    feature -> test -> error -> debug -> checkpoint -> feature


1. COMPLETED Run the program
    - COMPLETED

2. DONE Run with statemanager, go between 3 states
    - add test cases
        - can do empty calls to and from each state
        - COMPLETED
    - add documentation on statemanager and supporting components
        - high level how it works
        - examples for how to add new states
        - COMPLETED

3. DONE StateManager with state init
    - Prompt:
        In GameInitState I want to load @team_sample.json . I want to take this JSON parse it to a C# object
        and store that object in an object that all States have access to. I want this object to then be accessible
        in the next state transition MapSetupState. Your steps:
            - Add code in GameInitState that loads the @team_sample.json
            - Use @TeamConfigLoader.cs to create the object
            - All versions of @State.cs should be able to hold this object
            - @IState.cs may need to be modified as well
        - reads JSON on the teams
        - passes to object
        - goes to next state with that object
        - next state uses that objec to make the teams
        - COMPLETED
    - test cases:
        - tbd
    - documentation
        - COMPLETED

4. Add other components to state init for the json
    - Planning:
        - I want a master config file.
            - rules for the combat
                - victory condition
                - alliance between teams
            - This will have the teams to load
                - for now player units are in teams in future can be written out
            - the map to load
                - config settings on the map
                - for now: unique id, x, y, z, traversable, terrain, can a player unit start there
    - Prompt
        Expand @GameContext.cs to hold a game config json file. This will require:
            - A game_config.json file in the Configs directory.
                - This file will have:
                    - A section for general that has a key "victory_condition":"last_team_standing" and "alliances" which is list
                    - A section for teams to load, which will be a list of teams to load.
                    This list should be populated with team_sample.json and team_sample_2.json
                    - A section for the map to load. This will be a key value pairing with a TBD map to load
            - Something similar to @TeamConfigLoader.cs will have to be added to Utils to load the config
            - @GameContext will have to be expanded to hold the game config, multiple teams, and map
            - This config will be loaded in @GameInitState.cs
            - @GameInitState.cs will now load all teams listed in the game config and not a single, hardcoded team
        - COMPLETED
    - map
        - COMPLETED Planning: json file.
            - review what was in old version
        -COMPLETED Prompt
            In the Utils directory make a MapConfigLoader.cs file similar to @GameConfigLoader.cs .
            In @GameInitState.cs load the map. Pass the map to to @GameContext.cs.
            
    - COMPLETED reads and passes to the next state with that object
        - COMPLETED general and teams
        - map
    - test cases
    - documentation
        Prompt:
        Write documentation in docs directory on creating a new map, loading a map, and how it is used.
        At the top of the new file have a checklist for when creating a new map.
        Add the file to docs/README.MD .

5. sets up teams, units, victory conditions
    Prompt:
    You are now in CombatState.cs . You have a GameContext.cs object passed in from earlier files.
    In that GameContext.cs file you have a GameConfig class. Use that GameConfig class to populate values
    in XXX needed for victory conditions and other game config related information.
    
    Populate in @CombatTeamManager.cs XXX the teams and alliances from
    Populate in @victoryXXX the victory conditions from
    Populate the units in @XXX from XXX

    - test cases
    - documentation

6. integrates the core game engine and loop parts
    - me: maybe plan out the game loop a bit better with my queue ideas
    So the abstraction is three fold
        one: bunch of waiting stuff like for RL, WA, MP that not dealing with here
        one is the time flow that is like being in the game world:
            Tick increment, CT increment, status decrement, slow action decrement
                Phases.StatusTick:
                Phases.SlowActionTick:
                Phases.CTIncrement:

            me: maybe keep a tick variable as well

case 
                    ProcessStatusTick();
                    break;
                case 
                    ProcessSlowActionTick();
                    break;
                case Phases.SlowAction:
                    ProcessSlowAction();
                    break;  
                case 
                    ProcessCTIncrement();
                    break;
                case Phases.ActiveTurn:
                    ProcessActiveTurn();
                    break;      
                case Phases.EndActiveTurn:
                    ProcessEndActiveTurn();
                    break;
                case Phases.Mime:
                    ProcessMime();
                    break;
                case Phases.Reaction:
                    ProcessReaction();
                    break;
                case Phases.Quick:
                    ProcessQuick();
                    break;

        second is the 
    - combat engine, main loop
    - test cases
    - documentation

7. set up map with main functionality
    - map, tiles, etc. and what is needed
    - maybe delete mapinit state if not being used here. Idk, maybe keep it for rendering down the line?
    - test cases
    - documentation

8. what else is needed for MVP

9. minimal version of "UI" for testing with player interaction

10. what is needed for logging and analysis
    - minimal version